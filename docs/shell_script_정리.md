# Shell Script

## Shell 이란?
> 쉘은 사용자와 커널 사이의 연결다리

사용자로 부터 명령을 받아 커널에게 전달하여 명령 실행할 수 있도록 해줌
<br>cf) 커널 -> 하드웨어에 명령을 기계어로 번역하여 전달

## Shell 의 종류
`대표적인 shell 5개`
1. `sh 쉘` Bourne shell `개발자: 스티브 본` `최초의 쉘`
2. `csh 쉘` C shell `개발자: 빌 조이` `Bourne shell 개선 & C언어 기반`
3. `tcsh 쉘` tee-see-shell `개발: 카네기 멜런 대학교 학생들` `C shell 개선버전`
4. `zsh 쉘` Z shell `개발자: 폴 폴스타드` `확장형 bourne shell`
5. `bash 쉘` ***Bourne-again-shell*** `개발자: 브라이언 폭스` `가장 많이 사용되는 쉘` `리눅스, 맥 기본 쉘`

> 쉘은 bash뿐만 아니라 여러 종류가 존재한다! 그 중 가장 많이 쓰이는 게 bash!

<br>

## Shell Script 란?
- 쉘에 전달할 명령문을 모아 작성한 실행 파일
- 암묵적으로 쉘 실행파일은 `.sh`라는 확장자 붙여줌
- 여러 명령을 자동으로 실행 시킬 수 있음
  - 파일 실행 한 번으로 여러줄을 쉘에서 수동으로 입력해야하는 수고를 덜 수 있음

## Shell Script의 장점
- 반복되는 작업(명령) 자동화 가능 (crontab 등록)
- 컴파일 단계가 없어 빠른 실행 가능
- 명령어를 모르는 사용자도 파일실행만으로 작업 수행 가능

<br>

## Shell Script 권한 부여
> Shell Script 파일은 생성한 후에 실행 권한을 부여 해줘야한다!
- `chmod 755 파일명.sh` 또는 `chmod +x 파일명.sh`

## Shell Script 파일 실행
- `./파일명.sh` 또는 `절대경로/파일명.sh` (직접 실행)
- `sh` 파일명.sh
- `bash` 파일명.sh

<br>

## Shell Script 작성 시 주의사항
> 스크립트 작성 전 제일 먼저 최상단에 ***쉘 선언*** 을 해주어야 한다

`#!/bin/bash`

- `#!` : 스크립트 실행할 쉘을 지정한다는 의미
- `/bin/bash` : bash 명령 절대 경로
- = bash 쉘로 스크립트를 실행한다

## Shell Script 작성

---
### 입력 / 출력
- 입력 : read
- 출력 : echo
  - `-e` 백슬래시 escape 활성화
  - `-n` 마지막에 자동으로 붙는 줄바꿈 문자 제거
    <br>(줄바꿈없이 출력해야할 때 써준다)

※ 옵션은 쉘마다 다를 수 있으니 사용하는 쉘에서 manual을 확인해보자!
> mac에서 -e 옵션을 테스트해봤는데 동작하지 않아서 우분투에서 확인해보니 잘되었다..
> <br>한참 헤메다가 알게되었는데 `man echo` 명령어를 통해 매뉴얼을 확인해보니 서로 사용가능한 옵션이 달랐다!

<br>

---
### 색상 설정
`\033` + `[` + 텍스트속성 값 + `;` + 색상코드 + `m`

- 텍스트 속성

|  코드   | 속성              |
|:-----:|-----------------|
|   0   | 기본색상/Regular    |
|   1   | 밝은색상/Bold       |
|   2   | 어두운색상           |
|   3   | 이탤릭체            |
|   4   | 밑줄체             |
|   7   | 백그라운드/폰트 색상 반전체 |
|   9   | 취소선             |

- 색상 코드

| 색상     | 코드   |
|--------|------|
| white  | 1;37 |
| black  | 0;30 |
| red    | 0;31 |
| green  | 0;32 |
| orange | 0;33 |
| yellow | 1;33 |
| blue   | 0;34 |
| purple | 0;35 |
| cyan   | 0;36 |

<br>

---
### 변수
- 선언 : 영문자, 숫자, 언더바 사용
- 값 저장 : `=`뒤에 공백없이 작성 (공백들어가는 문자열일 경우 `"`(쌍따옴표) 로 감싼다)
- 사용(호출) : `$변수명` 또는 `${변수명}`
- 읽기전용으로 선언 : readonly 변수명
- 삭제 : unset 변수명

사용 예
```shell
VAR="hello world"
echo "선언한 변수 VAR의 값은 $VAR 입니다"
VAR="chaned value"
echo "수정된 변수 VAR의 값은 $VAR 입니다"
readonly VAR
VAR="chaned readonly value"
echo "변수 VAR의 값은 수정되었을까? 현재 VAR의 값은 $VAR"
```
출력결과
```
선언한 변수 VAR의 값은 hello world 입니다
수정된 변수 VAR의 값은 chaned value 입니다
./scriptTest.sh: line 37: VAR: readonly variable
변수 VAR의 값은 수정되었을까? 현재 VAR의 값은 chaned value
```
(readonly 변수에 새로운 값을 대입하려하니 오류가 나고 값이 수정되지 않은 것 확인 가능)

<br>

---
### shell script에 인수를 전달하자
> 스크립트 실행 시 스크립트 파일명 뒤에 공백으로 구분하여 값 입력 시 순서대로 인수 전달이 가능하다

ex) `./script.sh hello world`
<br>hello -> 첫번째 인수
<br>world -> 두번째 인수

### 인수 호출
- $0 : 스크립트명
- $n : n번째 인수 (위의 예에서 hello는 $1, world는 $2)
- $# : 스크립트에 전달된 인수 개수
- $$ : 이 쉘 스크립트 실행 프로세스 ID
- $! : 마지막으로 실행한 백그라운드 프로세스 ID
- $? : 직전에 실행한 커맨드의 실행결과 (0:성공, 1:실패)
- $* : 모든 인수 하나로 처리
- $@ : 모든 인수 각각 처리

---
### 배열
- 선언 및 초기화 : 변수명=(값1 값2 값3 ...)
- 호출 : ${변수명[i]} `주의) 중괄호 붙여야함`
- 값 대입(수정) : 변수명[i]=값

<br>

---
### 조건문
- if
```shell
if [ 조건문 ]
then 
    커맨드
elif [ 조건문 ]
then
    커맨드
else
    커맨드
fi
```

- switch
```shell
VAR=값
case "$VAR" in
    값) 커맨드 
    ;;
    값) 커맨드 
    ;;
    값) 커맨드 
    ;;
esac
```

<br>

---
### 반복문

- while
```shell
while [ 조건문 ]
do
    커맨드
done
```

- until
```shell
until [ 조건문 ]
do
    커맨드
done
```

- for
```shell
for 변수명 in 값1 값2 값3
do
    커맨드
done
```
반복할 변수 값 지정 방법
- `값1 값2 값3` 공백으로 구분
- `{값1,값2,값3}` 중괄호와 콤마로 구분

<br>

---
### 함수
함수 선언
```shell
함수명() {
  커맨드
}
```
함수 호출
```shell
함수명 인자1 인자2 ...
```
스크립트에 전달한 인자 사용할 때와 동일하게 함수 작성 코드 안에서 $n을 써서 사용
